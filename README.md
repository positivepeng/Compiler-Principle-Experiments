# Compiler-Principle-Experiments
编译原理课程实验[cqu]

## 实验一：词法分析
- 实验要求：识别代码中的非法字符，浮点数，八进制/十六进制，注释<br>
- 实现思路：数学正则表达式先匹配合法的再匹配不合法的<br>

注：使用正则表达式对代码进行匹配时如果匹配成功则执行规则部分定义的匹配成功的操作，否则直接将原始代码输出。<br>

## 实验二：语法分析
- 实验要求：
    1. 语法分析，打印语法树
    2. 识别常见的语法错误并输出具体位置
    3. 错误恢复
- 实现思路：
    1. 在使用推导式进行规约的时候进行语法树的构造
    2. 在原有的推导规则中增加包含error(关键词)的推导式，实现错误检测以及恢复
    3. 还有一种错误恢复的方式是预先猜想可能产生的错误，定义额外的推导式对其进行匹配然后恢复。

参考链接：
1. [使用Flex+Bison写计算器](https://github.com/meyerd/flex-bison-example)
2. [Error Recovery](https://www.gnu.org/software/bison/manual/html_node/Error-Recovery.html)
3. [非常简单的错误处理示例](http://marvin.cs.uidaho.edu/Teaching/CS445/bisonErrorToken.html)

## 实验三：语义分析
- 实验要求：
    1. 对整型和浮点型变量的进行类型检查，两类变量不能相互赋值及运算
    2. 函数仅能定义一次、程序中所有变量均不能重名
    3. 能检查结构体中域是否与变量重名，不同结构体中域是否重名
    4. 以上报错信息需输出错误位置
- 实现思路：
    1. 每个Exp结点都对应一个类型，所以遍历语法树中的Exp，完成类型检查
    2. 自定义符号表，每次出现函数、结构体或者变量定义时，查询符号表，避免重名
    3. 出现错误时输出节点所在行信息

## 实验四：中间代码及目标代码生成
- 实验要求：生成中间代码和目标代码[目前只支持赋值和加减乘除]
- 实现思路：实验语法制导翻译对语法树进行翻译，生成中间代码，然后选择寄存器分配策略生成目标代码
